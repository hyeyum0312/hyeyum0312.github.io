---
future: true
layout: single
title: "[React] React Hooks 탐구하기"
---

# **🔍 React Component 종류**

리액트 컴포넌트는 **함수형 컴포넌트**(Functional Component)와 클래스형 컴포넌트(Class Component)로 나뉩니다.

---

# **🔍** 함수형 컴포넌트가 사용된 이유

**함수형 컴포넌트가 등장한 이유**는 클래스형 컴포넌트의 여러 단점을 보완하기 위해서입니다.

클래스형 컴포넌트의 대표적인 단점은 다음과 같습니다:

- **`this` 바인딩 필요**: 메서드를 사용할 때마다 `this`를 수동으로 바인딩해야 해서 코드가 번거로워집니다.
- **복잡한 생명주기 관리**: 여러 생명주기 메서드를 사용해 상태와 사이드 이펙트를 분리 관리해야 하므로 코드가 복잡해집니다.
- **재사용성 제한**: 상태 관련 로직을 분리하거나 재사용하기 어려워 코드의 중복이 발생할 수 있습니다.

이러한 클래스형 컴포넌트의 단점을 보완하여, 함수형 컴포넌트(Functional Component)와 함께 사용되는 것이 바로 React Hooks(리액트 훅)입니다.

---

# **🔍** React Hooks, 무엇일까요?

React Hooks는 **함수형 컴포넌트에서 상태 관리와 생명주기 메서드 기능을 사용할 수 있게 해주는 함수**입니다.

이를 통해 함수형 컴포넌트에서도 클래스형 컴포넌트와 같은 기능을 쉽게 사용할 수 있습니다.

- **함수형 컴포넌트에서도 상태를 관리할 수 있습니다**:
- **생명주기 메서드 대신 사용 가능합니다.**
- **반복되는 로직을 쉽게 재 사용할 수 있습니다.**
- **관심사의 분리를 통해 코드를 구조화할 수 있습니다.**

---

# **🔍** ReactHooks, 왜 생겨났을까요?

**이전의 React에서는 컴포넌트 간에 로직을 쉽게 재사용할 방법이 없었습니다.**

그래서 같은 로직을 여러 곳에서 사용하려면 코드가 복잡해지고, 래퍼 지옥(wrapper hell)이라 불리는 상황이 발생했습니다. 이는 너무 많은 컴포넌트가 서로 감싸여 있는 상태입니다.

**이 문제는 React가 상태 관련 로직을 공유하는 데 어려움을 겪어서 생겼습니다.**

이를 해결하기 위해 더 나은 방법이 필요했습니다.

그래서 **React Hooks**는 16.8 버전부터 추가되었습니다.

이제 함수형 컴포넌트에서도 상태 관리와 생명주기 기능을 사용할 수 있게 되었습니다.

---

### **✅ 클래스 컴포넌트**

- **생명주기 메서드**를 통해 로직을 처리합니다.
- 여러 생명주기 메서드에 복잡한 로직이 들어가면 재사용이 어렵습니다.
- 같은 로직을 사용하려면 각 메서드마다 코드를 따로 작성해야 하므로 복잡해집니다.
- 예를 들어, `componentDidMount`와 `componentDidUpdate`에서 서로 다른 로직이 섞이면 버그가 발생할 가능성이 높습니다.

### **✅ 함수형 컴포넌트 + React Hooks**

- **Hooks**를 사용하여 상태 관리와 생명주기 기능을 쉽게 사용할 수 있습니다.
- 로직을 **작은 함수로 나누어** 재사용이 용이합니다.
- 복잡한 로직을 여러 부분으로 나누어 작성할 필요가 없으므로, 가독성과 유지보수가 쉬워집니다.
- 예를 들어, 데이터를 가져오는 로직과 이벤트 리스너 설정 로직을 별도의 Hook으로 관리할 수 있습니다.

---

# **🔍** Hooks의 사용 시 주의할 점

**최상위에서만 호출하기**

- Hooks는 **React 함수 컴포넌트 내에서만** 호출해야 합니다.
- 커스텀 Hooks는 이름이 "use"로 시작하는 함수 내에서 호출할 수 있습니다.
- **일반 JavaScript 함수**에서는 Hooks를 사용하지 마세요.

**React 함수 내에서 호출하기**

- Hooks는 **오직 React 함수 컴포넌트**에서만 호출해야 합니다.

### ESLint 플러그인 활용

- React는 Hooks 규칙을 자동으로 확인하는 **ESLint 플러그인**을 제공합니다.

https://www.npmjs.com/package/eslint-plugin-react-hooks

```jsx
npm install eslint-plugin-react-hooks --save-dev
```

ESLint 설정 파일 (.eslintrc.json 또는 .eslintrc.js)에 다음을 추가합니다:

```json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

1. **상태 일관성 유지**: Hooks 호출 순서에 의존하므로, 조건부 호출은 피해야 합니다.

   ```jsx
   const ExampleComponent = ({ shouldFetch }) => {
     // 잘못된 예: 조건부로 useState 호출
     if (shouldFetch) {
       const [data, setData] = useState(null);
       // ...
     }

     return <div>Example Component</div>;
   };
   ```

2. **부수 효과 일관성**: `useEffect` 같은 Hooks는 렌더링 후 실행되므로, 조건부 호출은 예상치 못한 동작을 유발할 수 있습니다.

   ```jsx
   // 잘못된 예: 조건부로 useEffect 호출
   if (shouldRunEffect) {
     useEffect(() => {
       console.log("Effect is running");
       // 부수 효과 로직
     }, []);
   }
   ```

3. **재사용성 향상**: 최상위에서 호출하여 커스텀 Hooks를 쉽게 재사용할 수 있습니다.
4. **디버깅 용이성**: 규칙을 지키면 Hooks 관련 버그를 더 쉽게 찾고 수정할 수 있습니다.

이러한 규칙들을 준수하면 Hooks를 사용하는 React 애플리케이션의 안정성과 예측 가능성이 크게 향상됩니다.

(예: 의존성 배열 관리 등)도 짚어주면 독자에게 유익할 것입니다.

---

# **🔍** 훅의 동작 원리

리액트는 Reconciler를 통해 상태 변화와 렌더링을 관리하며,

각 훅은 현재 컴포넌트의 상태와 생명주기를 담당하는 디스패처에 의해 처리됩니다.

이를 통해 상태 관리, 사이드 이펙트 처리, 리렌더링 등이 일관된 흐름으로 동작하게 됩니다.

**리액트 훅의 동작은 다음과 같은 순서로 진행됩니다:**

1. **컴포넌트 렌더링 시작**:

   리액트는 컴포넌트를 렌더링하면서 `resolveDispatcher()`를 호출해 훅을 처리하는 **디스패처**를 가져옵니다.

2. **훅 호출 및 상태 관리**:

   `useState`, `useEffect` 같은 훅을 호출하면 **디스패처는 내부적으로 상태와 사이드 이펙트를 관리**합니다.

   **useState**는 상태를 저장하고, **useEffect**는 컴포넌트가 렌더링된 후 실행될 작업을 설정합니다.

3. **상태 변경**:

   `setState`나 `dispatch`로 상태가 변경되면, **업데이트 정보는 업데이트 큐**에 저장되고 필요한 컴포넌트를 다시 렌더링합니다.

4. **리렌더링**:

   변경된 상태를 바탕으로 컴포넌트가 다시 호출되며, 리액트는 **가상 DOM**을 사용해 필요한 부분만 효율적으로 업데이트합니다.

5. **클린업 및 새로운 사이드 이펙트**:

   `useEffect`에서 이전 사이드 이펙트를 정리한 후, 새로운 사이드 이펙트를 실행합니다.

**훅이 개발자에게 도달되는 흐름은 다음과 같다고 합니다.**

```jsx
reconciler
-> shared/ReactSharedInternal
-> react/ReactSharedInternal
-> react/ReactCurrentDispatcher
-> react/ReactHooks
-> react
-> 개발자
```

### 각 요소의 역할

1. **Reconciler**:
   - 리액트의 UI를 업데이트하고, 상태 변화를 관리하는 주요 엔진입니다. 이 단계에서 컴포넌트의 변경 사항을 계산하고, 필요한 업데이트를 결정합니다.
2. **shared/ReactSharedInternal**:
   - 리액트의 내부 상태와 관련된 공유 모듈입니다. 여기서 훅과 상태 관리에 필요한 로직이 포함되어 있습니다.
3. **react/ReactSharedInternal**:
   - 리액트의 핵심 로직과 관련된 모듈로, 컴포넌트와 훅을 관리하는 기능을 포함합니다.
4. **react/ReactCurrentDispatcher**:
   - 현재 렌더링 중인 컴포넌트의 디스패처를 추적합니다. 각 컴포넌트가 사용하는 훅이 어떤 디스패처를 사용할지를 결정하는 역할을 합니다.
5. **react/ReactHooks**:
   - 리액트 훅의 구현체를 포함하며, `useState`, `useEffect`, `useContext` 등 다양한 훅의 로직을 정의합니다. 이곳에서 실제 훅이 어떻게 작동하는지를 구현합니다.
6. **react**:
   - 리액트 라이브러리의 최상위 모듈로, 컴포넌트와 훅을 사용하여 UI를 구축하는 데 필요한 API를 제공합니다.
7. **개발자**:
   - 리액트 API를 사용하여 컴포넌트를 작성하고 훅을 호출합니다. 개발자는 자신의 애플리케이션에서 상태 관리 및 사이드 이펙트를 처리하는 데 훅을 사용하여 효율적인 코드를 작성합니다.

### 정리

- `mountState`는 리액트에서 상태를 초기화하고 저장하는 데 사용되는 메서드입니다.
- 초기값을 받아 상태를 설정하고, 상태 변경 함수를 반환하여 컴포넌트의 상태 관리 기능을 제공합니다.
- 상태 변경 시, 리액트는 이전 상태와 새로운 상태를 비교하고, 변경된 경우 해당 컴포넌트를 리렌더링합니다.
- 훅의 호출 순서가 항상 일정해야 하며, 이를 통해 리액트는 상태를 일관되게 관리할 수 있습니다.

---

# 🧐 결론

1. 클래스 컴포넌트에서는 **로직을 재사용하기 어려웠고**
2. 고차 컴포넌트나 render Props 패턴을 사용했지만 이로인해 **복잡한 구조**가 만들어지곤 했습니다.

**Hooks는 이를 간결하게 해결 할 수 있도록 해줍니다.**

---

# 🎸 번외

간략하게 정리, 자세하게는 다음에 정리 해보겠습니다 🙂

## React 훅 과 React Query

React Query는 React 훅이 도입된 후에 만들어진 라이브러리입니다. 2018년 10월, 리액트 16.8 버전에서 훅이 도입되면서 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 쉽게 사용할 수 있게 되었습니다.

이런 변화는 React Query와 같은 라이브러리가 발전하는 데 큰 영향을 미쳤습니다.

결론적으로, React Query는 서버 상태 관리를 간편하게 해주는 라이브러리로, 개발자들이 데이터 fetching과 관리 로직을 더 쉽게 구현할 수 있도록 도와줍니다.

## 의존성 배열

의존성 배열은 React의 `useEffect`, `useMemo`, `useCallback` 훅에서 사용되는 중요한 개념입니다.

이 배열은 특정 값의 변화를 감지하여 해당 훅의 실행 여부를 결정하는 데 사용됩니다.

`useEffect`의 의존성 배열은 해당 훅이 실행되는 조건을 설정합니다.

`useMemo`의 의존성 배열은 메모이제이션된 값을 재계산해야 하는지를 결정합니다.

`useCallback`의 의존성 배열은 메모이제이션된 콜백 함수가 언제 재생성되는지를 결정합니다.

### 의존성 배열의 규칙

- **빈 배열 (`[]`)**:

  - 처음 렌더링될 때만 실행됩니다. 컴포넌트가 마운트될 때 한 번만 실행되며,
  - 업데이트 시에는 실행되지 않습니다.

- **상태나 prop을 포함한 배열**: 배열에 포함된 상태나 prop이 변경될 때마다 `useEffect`가 다시 실행됩니다.

- **조건 없이 호출하지 않기**: 의존성 배열을 지정하지 않으면 컴포넌트가 매번 렌더링될 때마다 해당 훅이 실행됩니다. 이는 성능에 악영향을 줄 수 있습니다.

---

## **usehook-ts 라이브러리**

```bash
npm i usehooks-ts
```

`usehooks-ts`는 TypeScript를 사용하는 React 개발자에게 유용한 라이브러리로, 다양한 커스텀 훅을 제공하여 코드의 재사용성을 높이고 효율성을 증가시킵니다. 이를 통해 개발자는 반복적인 작업에서 벗어나 더 나은 사용자 경험을 제공할 수 있습니다.

- 참고

- [usehooks-ts 공식 사이트](https://usehooks-ts.com/)
- [Dark Mode 훅 문서](https://usehooks-ts.com/react-hook/use-dark-mode)
- [Velog 포스트: usehooks-ts](https://velog.io/@jeong_lululala/usehooks-ts)
- [React 훅 소개 (구 버전)](https://ko.legacy.reactjs.org/docs/hooks-intro.html#ts-hard-to-reuse-stateful-logic-between-components)
- [Tistory 포스트: 잘 만들어진 코드 스토리](https://well-made-codestory.tistory.com/44)
- 항해99 학습자료.
