---
future: true
layout: single
title: "[React] React Hooks 탐구하기"
---

# ReactHooks

# **🔍 React Component 종류**

리액트 컴포넌트는 **함수형 컴포넌트**(Functional Component)와 클래스형 컴포넌트(Class Component)로 나뉩니다.

## **🔍** 함수형 컴포넌트(Functional Component)가 사용된 이유

**함수형 컴포넌트가 등장한 이유**는 클래스형 컴포넌트의 여러 단점을 보완하기 위해서입니다.

대표적인 단점은 다음과 같습니다:

- **복잡한 코드 구조**: 클래스형 컴포넌트는 `this` 바인딩과 같은 추가적인 처리로 인해 코드가 복잡해집니다.
- **재사용성 저하**: 클래스형 컴포넌트에서는 로직을 여러 곳에서 재사용하기가 어렵습니다.
- **최적화의 어려움**: 클래스형 컴포넌트는 컴파일 단계에서 최적화를 어렵게 하며, 최신 기술을 효과적으로 적용하기 힘듭니다.

이러한 클래스형 컴포넌트의 단점을 보완하여, 함수형 컴포넌트(Functional Component)와 함께 사용되는 것이 바로 React Hooks(리액트 훅)입니다.

---

# **🔍** React Hooks, 무엇일까요?

React Hooks는 함수형 컴포넌트에서 상태 관리와 생명주기 메서드 기능을 사용할 수 있게 해주는 함수입니다.

이를 통해 함수형 컴포넌트에서도 클래스형 컴포넌트와 같은 기능을 쉽게 사용할 수 있습니다.

- **함수형 컴포넌트에서도 상태를 관리할 수 있습니다**:
- **생명주기 메서드 대신 사용 가능합니다.**
- **반복되는 로직을 쉽게 재 사용할 수 있습니다.**
- **관심사의 분리를 통해 코드를 구조화할 수 있습니다.**

---

# **🔍** ReactHooks, 왜 생겨났을까요?

**이전의 React에서는 컴포넌트 간에 로직을 쉽게 재사용할 방법이 없었습니다.**

그래서 같은 로직을 여러 곳에서 사용하려면 코드가 복잡해지고, 래퍼 지옥(wrapper hell)이라 불리는 상황이 발생했습니다. 이는 너무 많은 컴포넌트가 서로 감싸여 있는 상태입니다.

**이 문제는 React가 상태 관련 로직을 공유하는 데 어려움을 겪어서 생겼습니다.**

이를 해결하기 위해 더 나은 방법이 필요했습니다.

그래서 **React Hooks**는 16.8 버전부터 추가되었습니다.

이제 함수형 컴포넌트에서도 상태 관리와 생명주기 기능을 사용할 수 있게 되었습니다.

---

### **✅ 클래스 컴포넌트**

- **생명주기 메서드**를 통해 로직을 처리합니다.
- 여러 생명주기 메서드에 복잡한 로직이 들어가면 재사용이 어렵습니다.
- 같은 로직을 사용하려면 각 메서드마다 코드를 따로 작성해야 하므로 복잡해집니다.
- 예를 들어, `componentDidMount`와 `componentDidUpdate`에서 서로 다른 로직이 섞이면 버그가 발생할 가능성이 높습니다.

### **✅ 함수형 컴포넌트 + React Hooks**

- **Hooks**를 사용하여 상태 관리와 생명주기 기능을 쉽게 사용할 수 있습니다.
- 로직을 **작은 함수로 나누어** 재사용이 용이합니다.
- 복잡한 로직을 여러 부분으로 나누어 작성할 필요가 없으므로, 가독성과 유지보수가 쉬워집니다.
- 예를 들어, 데이터를 가져오는 로직과 이벤트 리스너 설정 로직을 별도의 Hook으로 관리할 수 있습니다.

---

# **🔍** Hooks의 사용 시 주의할 점

**최상위에서만 호출하기**

- Hooks는 **React 함수 컴포넌트 내에서만** 호출해야 합니다.
- 커스텀 Hooks는 이름이 "use"로 시작하는 함수 내에서 호출할 수 있습니다.
- **일반 JavaScript 함수**에서는 Hooks를 사용하지 마세요.

**React 함수 내에서 호출하기**

- Hooks는 **오직 React 함수 컴포넌트**에서만 호출해야 합니다.

### ESLint 플러그인 활용

- React는 Hooks 규칙을 자동으로 확인하는 **ESLint 플러그인**을 제공합니다.

https://www.npmjs.com/package/eslint-plugin-react-hooks

```jsx
npm install eslint-plugin-react-hooks --save-dev
```

ESLint 설정 파일 (.eslintrc.json 또는 .eslintrc.js)에 다음을 추가합니다:

```json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

1. **상태 일관성 유지**: Hooks 호출 순서에 의존하므로, 조건부 호출은 피해야 합니다.

   ```jsx
   const ExampleComponent = ({ shouldFetch }) => {
     // 잘못된 예: 조건부로 useState 호출
     if (shouldFetch) {
       const [data, setData] = useState(null);
       // ...
     }

     return <div>Example Component</div>;
   };
   ```

2. **부수 효과 일관성**: `useEffect` 같은 Hooks는 렌더링 후 실행되므로, 조건부 호출은 예상치 못한 동작을 유발할 수 있습니다.

   ```jsx
   // 잘못된 예: 조건부로 useEffect 호출
   if (shouldRunEffect) {
     useEffect(() => {
       console.log("Effect is running");
       // 부수 효과 로직
     }, []);
   }
   ```

3. **재사용성 향상**: 최상위에서 호출하여 커스텀 Hooks를 쉽게 재사용할 수 있습니다.
4. **디버깅 용이성**: 규칙을 지키면 Hooks 관련 버그를 더 쉽게 찾고 수정할 수 있습니다.

이러한 규칙들을 준수하면 Hooks를 사용하는 React 애플리케이션의 안정성과 예측 가능성이 크게 향상됩니다.

(예: 의존성 배열 관리 등)도 짚어주면 독자에게 유익할 것입니다.

# 결론

1. 클래스 컴포넌트에서는 **로직을 재사용하기 어려웠고**
2. 고차 컴포넌트나 render Props 패턴을 사용했지만 이로인해 **복잡한 구조**가 만들어지곤 했습니다.

**Hooks는 이를 간결하게 해결 할 수 있도록 해줍니다.**

---

# 🎸 번외

간략하게 정리, 자세하게는 다음에 정리 해보겠습니다 🙂

## React 훅 과 React Query

React Query는 React 훅이 도입된 후에 만들어진 라이브러리입니다. 2018년 10월, 리액트 16.8 버전에서 훅이 도입되면서 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 쉽게 사용할 수 있게 되었습니다.

이런 변화는 React Query와 같은 라이브러리가 발전하는 데 큰 영향을 미쳤습니다.

결론적으로, React Query는 서버 상태 관리를 간편하게 해주는 라이브러리로, 개발자들이 데이터 fetching과 관리 로직을 더 쉽게 구현할 수 있도록 도와줍니다.

## 의존성 배열

의존성 배열은 React의 `useEffect`, `useMemo`, `useCallback` 훅에서 사용되는 중요한 개념입니다.

이 배열은 특정 값의 변화를 감지하여 해당 훅의 실행 여부를 결정하는 데 사용됩니다.

`useEffect`의 의존성 배열은 해당 훅이 실행되는 조건을 설정합니다.

`useMemo`의 의존성 배열은 메모이제이션된 값을 재계산해야 하는지를 결정합니다.

`useCallback`의 의존성 배열은 메모이제이션된 콜백 함수가 언제 재생성되는지를 결정합니다.

### 의존성 배열의 규칙

- **빈 배열 (`[]`)**:

  - 처음 렌더링될 때만 실행됩니다. 컴포넌트가 마운트될 때 한 번만 실행되며,
  - 업데이트 시에는 실행되지 않습니다.

- **상태나 prop을 포함한 배열**: 배열에 포함된 상태나 prop이 변경될 때마다 `useEffect`가 다시 실행됩니다.

- **조건 없이 호출하지 않기**: 의존성 배열을 지정하지 않으면 컴포넌트가 매번 렌더링될 때마다 해당 훅이 실행됩니다. 이는 성능에 악영향을 줄 수 있습니다.

---

## **usehook-ts 라이브러리**

```bash
npm i usehooks-ts
```

`usehooks-ts`는 TypeScript를 사용하는 React 개발자에게 유용한 라이브러리로, 다양한 커스텀 훅을 제공하여 코드의 재사용성을 높이고 효율성을 증가시킵니다. 이를 통해 개발자는 반복적인 작업에서 벗어나 더 나은 사용자 경험을 제공할 수 있습니다.

- 참고

- [usehooks-ts 공식 사이트](https://usehooks-ts.com/)
- [Dark Mode 훅 문서](https://usehooks-ts.com/react-hook/use-dark-mode)
- [Velog 포스트: usehooks-ts](https://velog.io/@jeong_lululala/usehooks-ts)
- [React 훅 소개 (구 버전)](https://ko.legacy.reactjs.org/docs/hooks-intro.html#ts-hard-to-reuse-stateful-logic-between-components)
- [Tistory 포스트: 잘 만들어진 코드 스토리](https://well-made-codestory.tistory.com/44)
- 항해99 학습자료.
